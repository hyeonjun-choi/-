 # 운영체계 메모리 및 프로세스에 대한 복습 보충
 
 최 현준

목차

1. 운영체계 정의

ⓐ. 운영체계 목적

ⓑ. 커널(kernel)과 명령어 해석기(Command interpreter, shell)

ⓒ. 운영체계의 위치

ⓓ. 운영체계의 기능

2. 운영체계 메모리

ⓐ. 운영체계 메모리 정의

ⓑ. Stack 영역과 Heap 영역 간의 비교

ⓒ. 메모리 종류

3. 운영체계 프로세스

ⓐ. 프로세스 구조

ⓑ. 프로세스 상태

ⓒ. PCB

ⓓ. 프로세스 분류




## 1. 운영체계 정의

사용자가 컴퓨터를 사용하기 위해 필요한 소프트웨어. 일반적으로 컴퓨터를 사용하면서 실행하는 모든 프로그램들은 운영체제에서 관리, 제어(ex; Window, Linux, OSX, IOS)

### ⓐ. 운영체계 목적

컴퓨터의 성능을 높이고(performance) 사용자에게 편의성을 제공(Convenience)을 위해 컴퓨터의 하드웨어(CPU, 메모리, 디스크, 키보드, 마우스, 모니터, 네트워크 등) 관리

### ⓑ. 커널(kernel)과 명령어 해석기(Command interpreter, shell)

커널 – 운영체제의 핵심. 수행하는 모든 것이 저장

명령어 해석기 – 사용자가 커널(운영체계)에 요청하는 명령어를 해석, 커널에 요청하고 결과 출력

사용자의 경우 GUI(Graphical User Interface)나 CLI(Command Line Interface)과 같은 방식으로 운영체제에 요청. (ex, 현재 디렉토리의 파일 리스트 불러오기, 프로그램 실행, 디스크 용량 확인 등)

### ⓒ. 운영체계의 위치

사용자 프로그램(Application)은 특정 운영체계에 맞춰서 만들어지므로 한 애플리케이션이 서로 다른 운영체계에서 수행될 수 없음.

https://user-images.githubusercontent.com/34755287/53879651-5b041180-4052-11e9-9b04-065091bd3199.png

하드웨어 자원을 직접적으로 사용하지 않고 운영체계가 제공하는 자원만을 사용

### ⓓ. 운영체계의 기능

프로세스, 메모리, 하드디스크 등 하드웨어의 효율적 사용, 관리

자원 관리를 위해 프로세스 관리, 메모리 관리, 디스크 관리, 네트워크, 보안 등 기능 분류

애플리케이션들의 요청에 따라 각 기능 수행

## 2. 운영체계 메모리

실행 중인 프로그램과 프로그램에 필요한 데이터를 일시적, 혹은 영구적으로 저장
CPU로부터 레지스터 → CPU캐시 메모리 → 메인 메모리 → 보조기억장치 → 외부기억장치 순으로 멀어지며 멀어질수록 데이터를 저장하는 용량이 커지고 접근 속도는 느려짐. 

### ⓐ. 메모리 구조

https://media.vlpt.us/images/goserimgoserimgo/post/5e3e1d1f-94d8-4e09-b55f-620ebb00c071/_2020-08-02__10.36.08.png

Code 영역(Text)

 코드를 실행하기 위해 저장되어있는 영역. 제어문, 함수, 상수과 같이 프로그램을 실행시키기 위해 구성되는 것들(명령문)이 저장되는 영역.

Data 영역

 사용자가 작성한 코드에서 전역변수, 정적변수 등이 저장되는 공간. 보통 메인 함수 전(프로그램 실행 전)에 선언되어 프로그램이 끝날 때 까지 메모리에 남아있는 변수들이라는 특징 가짐.
 초기화 된 변수 영역과 초기화되지 않은 변수 영역으로 나뉨.

Heap 영역

 프로그램이 실행되는 동안 동적으로 사용할 데이터가 저장되며 사용자가 직접 관리하는 영역으로 사용자에 의해 메모리가 동적으로 할당, 해제됨.
 
 class, closure와 같은 참조 타입 데이터가 저장되며 swift의 경우 ARC가 참조 타입의 할당, 해제 시점을 자동으로 관리, javaㅁ의 경우 가비지 콜렉터가 관리하며, C의 경우 사용자가 동적으로 할당, 해제.
 메모리의 낮은 주소에서 높은 주소로 할당되며 프로그램이 실행되는 도중에 힙 영역의 크기가 결정됨.

Stack 영역

 함수 호출 시 생성되는 지역 변수와 매개 변수가 저장되는 공간. 함수 종료 시 해당 함수에 할당된 변수들을 메모리에서 해제.
 높은 주소에서 낮은 주소로 메모리에 할당. 컴파일 시에 할당될 영역의 크기가 결정되며 운영체제에 따라 제한된 스택 영역의 크기가 다름.

### ⓑ. Stack 영역과 Heap 영역 간의 비교

스택 영역과 힙 영역은 사실상 같은 공간을 사용하는데 스택 영역이 클수록 힙 영역이 작아지고, 힙 영역이 클수록 스택영역이 작아짐.

스택 영역이 높은 주소 → 낮은 주소로 할당되고, 힙 영역이 낮은 주소 → 높은 주소로 할당되기 때문에 자신의 영역이 상대의 영역을 침범하는 사태가 발생할 수 있음. 이를 각각 스택 오버플로우, 힙 오버플로우 라고 명칭.

 할당 속도 비교
 
 스택은 컴파일 시 이미 할당된 공간을 사용 – 스택에서의 할당이란 이미 생성된 스택에 대해 포인터의 위치만 바꿔주는 단순한 CPU Instruction을 지칭.
 
 힙은 사용자가 따로 할당해서 사용하는 공간 – 힙에서의 할당이란 요청된 chunk의 크기, 현재 메모리의 fragmentation 상황 등 다양한 요소를 고려하기 때문에 더 많은 CPU Instruction을 지칭.
 
 이와 같은 차이로 인해 스택 할당 속도가 더 빠른 편.

### ⓒ. 메모리 종류

 캐시 메모리
 
 주기억장치에 저장된 내용의 일부를 임시로 저장해두는 기억장치. CPU와 주기억장치의 속도 차이로 인한 성능 저하를 방지하기 위한 방법으로 CPU가 이미 봤던 걸 다시 재접근할 때, 메모리 참조 및 인출 과정에 대한 비용을 줄이기 위해 캐시에 저장해둔 데이터를 활용.

메인 메모리

 CPU가 직접 접근할 수 있는 접근 장치. 프로세스가 실행되려면 프로그램이 메모리에 올라와야 가능. 현재 cpu에 의해 실행 중인 프로그램과 프로그램에 필요한 데이터를 일시저으로 저장하는 장치. DRAM(dynamic random access memory)으로 구현되며 전원을 끄면 모든 내용이 지워지는 휘발성 메모리.

하드디스크
 
 프로그램과 데이터를 영구 저장하는 장치. CPU 요구에 따라 저장되어 있는 프로그램과 데이터를 메인 메모리로 전송.

## 3. 운영체계 프로세스

메인 메모리에 할당되어 동작 중인 상태의 프로그램. 일반적으로 하드디스크(보조기억장치)에 저장되어 아무 일도 하지 않는 상태이며 실행하면서 stack pointer, data, text, register 등이 끊임없이 면함. job, task 등으로 불리기도 함.

### ⓐ. 프로세스 구조

 Text 영역: CPU에서 직접 수행되는 명령어를 가짐. Code 영역이라고도 하며, 코드 자체를 구성하는 메모리 영역으로 Hex 파일이나 Bin 파일 메모리임.

 Data 영역: 전역 변수가 이곳에 속하며 그 외에 프로그램이 실행될 때 생성되고 프로그램이 종료되면 시스템에 반환되며 정적변수, 배열, 구조체 등이 저장되는 곳. 이 때 초기화 된 데이터에는 data 영역에 저장되고, 초기화되지 않은 데이터는 BSS(Block Stated Symbol)영역에 저장됨.

 Heap 영역: 동적으로 할당 받은 내용을 가짐. 동적 데이터 영역이라고 불림. 메모리 주소 값에 의해서만 참조되고 사용되는 영역.

 Stack 영역: 지역변수와 인자, 그리고 함수의 리턴 주소를 가짐. 함수를 호출 시에 생성이 되고, 함수가 끝나면 반환. Stack 사이즈는 각 프로세스마다 할당되지만, 프로세스가 메모리에 로드될 때 Stack 사이즈가 고정되어 있어 런타임시에 Stack 사이즈를 바꿀 수 없음.

### ⓑ. 프로세스 상태
 
new : 프로그램이 메인 메모리에 할당됨.

ready : 할당된 프로그램이 초기화와 같은 작업을 통해 실행되기 위한 모든 준비를 마친 상태. 여러 개의 프로세스가 CPU를 할당 받기를 기다리며 존재.

running : cpu가 해당 프로세스 실행

waiting : 프로세스가 끝나지 않은 시점에서 I/O로 인해 cpu를 사용하지 않고 다른 작업을 수행(해당 작업이 끝나면 다시 cpu에 의해 실행되기 위해 ready상태로 돌아가야 함)

terminated : 프로세스 완전 종료

https://user-images.githubusercontent.com/34755287/70577651-11eb7a00-1bef-11ea-9866-0c659728be9e.png

### ⓒ. PCB

Provess Control Block의 줄임말.

운영체계가 프로세스를 제어하기 위해 프로세스에 대한 중요한 정보를 저장하는 구조체. 

프로세스 상태 관리와 Context Switching을 위해서 필요하며, PCB는 프로세스 생성시 만들어지며 주 기억장치에 유지됨.

PCB에 포함된 정보는 다음과 같음.

Process ID/ Process state / Program counter/ register information / scheduling information / Memory related information/ Accounting information / Status information related to I/O

PID : 프로세스의 고유 번호

State(상태) : 준비, 대기, 실행 등의 상태 의미

포인터 : 다음 실행될 프로세스의 포인터

Register save area : 레지스터 관련 정보

Priority : 스케줄링 및 크로세스의 우선순위 및 할당된 자원 정보

Account : CPU 실제 사용된 시간, 입출력 상태 정보


### ⓓ. 프로세스 분류

수행하는 역할에 따라 시그널(커널) 프로세스와 사용자 프로세스로 구분, 병행 수행 방법에 따라 독립 프로세스와 협력 프로세스로 구분.

<table border="1" cellspacing="0">
  <tr width="100px" height="50px" align="center">
    <td>구분
    </td>
    <td>종류
    </td>
    <td>설명
    </td>
  </tr>
<tr width="100px" height="50px" align="center">
    <td rowspan="2">역할
    </td>
    <td>시스템 프로세스
    </td>
    <td>모든 시스템 메모리와 프로세서의 명령에 액세스할 수 있는 프로세스. 프로세스 실행 순서 제어, 다른 사용자 및 커널 영역을 침범하지 못하게 감시, 사용자 프로세스를 생성하는 기능 수행.
    </td>
  </tr>
 <tr width="100px" height="50px" align="center">
    <td>사용자 프로세스
    </td>
    <td>사용자 코드를 수행하는 프로세스
    </td>
  </tr>
 <tr width="100px" height="50px" align="center">
    <td rowspan="2">병행수행방법
    </td>
    <td>독립 프로세스
    </td>
    <td>다른 포로세스에 영향을 주지 않거나 다른 프로세스의 영향을 받지 않으면서 수행하는 병행 프로세스
    </td>
  </tr>
 <tr width="100px" height="50px" align="center">
    <td>협력 프로세스
    </td>
    <td> 다른 포로세스에 영향을 주거나 다른 프로세스에서 영향을 받는 병행 프로세스
    </td>
  </tr>
</table>  

